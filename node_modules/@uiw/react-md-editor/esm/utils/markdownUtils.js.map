{
  "version": 3,
  "sources": [
    "../../src/utils/markdownUtils.ts"
  ],
  "names": [
    "getSurroundingWord",
    "selectWord",
    "text",
    "selection",
    "length",
    "start",
    "end",
    "getBreaksNeededForEmptyLineBefore",
    "startPosition",
    "neededBreaks",
    "isInFirstLine",
    "i",
    "charCodeAt",
    "getBreaksNeededForEmptyLineAfter",
    "isInLastLine"
  ],
  "mappings": "AACA,OAAOA,kBAAP,MAA+B,sBAA/B;AAOA,OAAO,SAASC,UAAT,OAAiE;AAAA,MAA3CC,IAA2C,QAA3CA,IAA2C;AAAA,MAArCC,SAAqC,QAArCA,SAAqC;;AACtE,MAAID,IAAI,IAAIA,IAAI,CAACE,MAAb,IAAuBD,SAAS,CAACE,KAAV,KAAoBF,SAAS,CAACG,GAAzD,EAA8D;AAC5D;AACA,WAAON,kBAAkB,CAACE,IAAD,EAAOC,SAAS,CAACE,KAAjB,CAAzB;AACD;;AACD,SAAOF,SAAP;AACD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASI,iCAAT,CAA2CL,IAA3C,EAAsDM,aAAtD,EAAqF;AAAA,MAA1CN,IAA0C;AAA1CA,IAAAA,IAA0C,GAAnC,EAAmC;AAAA;;AAC1F,MAAIM,aAAa,KAAK,CAAtB,EAAyB,OAAO,CAAP,CADiE,CAG1F;AACA;AACA;AACA;;AAEA,MAAIC,YAAY,GAAG,CAAnB;AACA,MAAIC,aAAa,GAAG,IAApB;;AACA,OAAK,IAAIC,CAAC,GAAGH,aAAa,GAAG,CAA7B,EAAgCG,CAAC,IAAI,CAAL,IAAUF,YAAY,IAAI,CAA1D,EAA6DE,CAAC,EAA9D,EAAkE;AAChE,YAAQT,IAAI,CAACU,UAAL,CAAgBD,CAAhB,CAAR;AACE,WAAK,EAAL;AAAS;AACP;;AACF,WAAK,EAAL;AAAS;AACPF,QAAAA,YAAY;AACZC,QAAAA,aAAa,GAAG,KAAhB;AACA;;AACF;AACE,eAAOD,YAAP;AARJ;AAUD;;AACD,SAAOC,aAAa,GAAG,CAAH,GAAOD,YAA3B;AACD;AAED;AACA;AACA;AACA;;AACA,OAAO,SAASI,gCAAT,CAA0CX,IAA1C,EAAqDM,aAArD,EAAoF;AAAA,MAA1CN,IAA0C;AAA1CA,IAAAA,IAA0C,GAAnC,EAAmC;AAAA;;AACzF,MAAIM,aAAa,KAAKN,IAAI,CAACE,MAAL,GAAc,CAApC,EAAuC,OAAO,CAAP,CADkD,CAGzF;AACA;AACA;AACA;;AAEA,MAAIK,YAAY,GAAG,CAAnB;AACA,MAAIK,YAAY,GAAG,IAAnB;;AACA,OAAK,IAAIH,CAAC,GAAGH,aAAb,EAA4BG,CAAC,GAAGT,IAAI,CAACE,MAAT,IAAmBK,YAAY,IAAI,CAA/D,EAAkEE,CAAC,EAAnE,EAAuE;AACrE,YAAQT,IAAI,CAACU,UAAL,CAAgBD,CAAhB,CAAR;AACE,WAAK,EAAL;AACE;;AACF,WAAK,EAAL;AAAS;AACPF,UAAAA,YAAY;AACZK,UAAAA,YAAY,GAAG,KAAf;AACA;AACD;;AACD;AACE,eAAOL,YAAP;AATJ;AAWD;;AACD,SAAOK,YAAY,GAAG,CAAH,GAAOL,YAA1B;AACD",
  "sourcesContent": [
    "import { TextRange } from '../commands';\nimport getSurroundingWord from './getSurroundingWord';\n\nexport interface TextSection {\n  text: string;\n  selection: TextRange;\n}\n\nexport function selectWord({ text, selection }: TextSection): TextRange {\n  if (text && text.length && selection.start === selection.end) {\n    // the user is pointing to a word\n    return getSurroundingWord(text, selection.start);\n  }\n  return selection;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the previous text\n */\nexport function getBreaksNeededForEmptyLineBefore(text = '', startPosition: number): number {\n  if (startPosition === 0) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInFirstLine = true;\n  for (let i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {\n    switch (text.charCodeAt(i)) {\n      case 32: // blank space\n        continue;\n      case 10: // line break\n        neededBreaks--;\n        isInFirstLine = false;\n        break;\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInFirstLine ? 0 : neededBreaks;\n}\n\n/**\n *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'\n *  to make sure there's an empty line between 'startPosition' and the next text\n */\nexport function getBreaksNeededForEmptyLineAfter(text = '', startPosition: number): number {\n  if (startPosition === text.length - 1) return 0;\n\n  // rules:\n  // - If we're in the first line, no breaks are needed\n  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we\n  //      may need to insert 0, 1 or 2 breaks\n\n  let neededBreaks = 2;\n  let isInLastLine = true;\n  for (let i = startPosition; i < text.length && neededBreaks >= 0; i++) {\n    switch (text.charCodeAt(i)) {\n      case 32:\n        continue;\n      case 10: {\n        neededBreaks--;\n        isInLastLine = false;\n        break;\n      }\n      default:\n        return neededBreaks;\n    }\n  }\n  return isInLastLine ? 0 : neededBreaks;\n}\n"
  ]
}
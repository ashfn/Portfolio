{
  "version": 3,
  "sources": [
    "../../src/utils/InsertTextAtPosition.ts"
  ],
  "names": [
    "browserSupportsTextareaTextNodes",
    "canManipulateViaTextNodes",
    "input",
    "nodeName",
    "textarea",
    "document",
    "createElement",
    "value",
    "firstChild",
    "insertTextAtPosition",
    "text",
    "focus",
    "selection",
    "ieRange",
    "createRange",
    "collapse",
    "select",
    "isSuccess",
    "execCommand",
    "start",
    "selectionStart",
    "end",
    "selectionEnd",
    "setRangeText",
    "range",
    "textNode",
    "createTextNode",
    "node",
    "appendChild",
    "offset",
    "startNode",
    "endNode",
    "nodeLength",
    "nodeValue",
    "length",
    "setStart",
    "setEnd",
    "nextSibling",
    "deleteContents",
    "commonAncestorContainer",
    "insertNode",
    "slice",
    "setSelectionRange",
    "e",
    "createEvent",
    "initEvent",
    "dispatchEvent"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/**\n * The MIT License\n * Copyright (c) 2018 Dmitriy Kubyshkin\n * Copied from https://github.com/grassator/insert-text-at-cursor\n */\n\nlet browserSupportsTextareaTextNodes: any;\n\n/**\n * @param {HTMLElement} input\n * @return {boolean}\n */\nfunction canManipulateViaTextNodes(input: HTMLTextAreaElement | HTMLInputElement) {\n  if (input.nodeName !== 'TEXTAREA') {\n    return false;\n  }\n  if (typeof browserSupportsTextareaTextNodes === 'undefined') {\n    const textarea: HTMLTextAreaElement = document.createElement('textarea');\n    textarea.value = '1';\n    browserSupportsTextareaTextNodes = !!textarea.firstChild;\n  }\n  return browserSupportsTextareaTextNodes;\n}\n\n/**\n * @param {HTMLTextAreaElement|HTMLInputElement} input\n * @param {string} text\n * @returns {void}\n */\nexport default function insertTextAtPosition(input: HTMLTextAreaElement | HTMLInputElement, text: string) {\n  // Most of the used APIs only work with the field selected\n  input.focus();\n\n  // IE 8-10\n  if ((document as any).selection) {\n    const ieRange = (document as any).selection.createRange();\n    ieRange.text = text;\n\n    // Move cursor after the inserted text\n    ieRange.collapse(false /* to the end */);\n    ieRange.select();\n\n    return;\n  }\n\n  // Webkit + Edge\n  const isSuccess = document.execCommand && document.execCommand('insertText', false, text);\n  if (!isSuccess) {\n    const start = input.selectionStart!;\n    const end = input.selectionEnd!;\n    // Firefox (non-standard method)\n    if (typeof input.setRangeText === 'function') {\n      input.setRangeText(text);\n    } else {\n      // To make a change we just need a Range, not a Selection\n      const range = document.createRange();\n      const textNode = document.createTextNode(text);\n\n      if (canManipulateViaTextNodes(input)) {\n        let node = input.firstChild;\n\n        // If textarea is empty, just insert the text\n        if (!node) {\n          input.appendChild(textNode);\n        } else {\n          // Otherwise we need to find a nodes for start and end\n          let offset = 0;\n          let startNode = null;\n          let endNode = null;\n\n          while (node && (startNode === null || endNode === null)) {\n            const nodeLength = node.nodeValue!.length;\n\n            // if start of the selection falls into current node\n            if (start >= offset && start <= offset + nodeLength) {\n              range.setStart((startNode = node), start - offset);\n            }\n\n            // if end of the selection falls into current node\n            if (end >= offset && end <= offset + nodeLength) {\n              range.setEnd((endNode = node), end - offset);\n            }\n\n            offset += nodeLength;\n            node = node.nextSibling;\n          }\n\n          // If there is some text selected, remove it as we should replace it\n          if (start !== end) {\n            range.deleteContents();\n          }\n        }\n      }\n\n      // If the node is a textarea and the range doesn't span outside the element\n      //\n      // Get the commonAncestorContainer of the selected range and test its type\n      // If the node is of type `#text` it means that we're still working with text nodes within our textarea element\n      // otherwise, if it's of type `#document` for example it means our selection spans outside the textarea.\n      if (canManipulateViaTextNodes(input) && range.commonAncestorContainer.nodeName === '#text') {\n        // Finally insert a new node. The browser will automatically split start and end nodes into two if necessary\n        range.insertNode(textNode);\n      } else {\n        // If the node is not a textarea or the range spans outside a textarea the only way is to replace the whole value\n        const value = input.value;\n        input.value = value.slice(0, start) + text + value.slice(end);\n      }\n    }\n\n    // Correct the cursor position to be at the end of the insertion\n    input.setSelectionRange(start + text.length, start + text.length);\n\n    // Notify any possible listeners of the change\n    const e = document.createEvent('UIEvent');\n    e.initEvent('input', true, false);\n    input.dispatchEvent(e);\n  }\n}\n"
  ]
}